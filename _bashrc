# vim: set ft=sh:

# Jacob Degeling's .bashrc file
# me@jacobdegeling.com

#if not interactive, get out of here
[[ -z "$PS1" ]] && return

export PATH=/usr/local/bin:/usr/local/sbin:/usr/local/share/npm/bin:$PATH

if [ -d ~/bin ]; then
    export PATH=~/bin:$PATH
fi

export EDITOR=vim

# command colouring
export CLICOLOR=1
export GREP_OPTIONS='--color=auto'


# define colors
C_DEFAULT="\[\033[m\]"
C_RESET="\[\033[0m\]"

C_BLACK="\[\033[0;30m\]"
C_RED="\[\033[0;31m\]"
C_GREEN="\[\033[0;32m\]"
C_YELLOW="\[\033[0;33m\]"
C_BLUE="\[\033[0;34m\]"
C_MAGENTA="\[\033[0;35m\]"
C_CYAN="\[\033[0;36m\]"
C_WHITE="\[\033[0;37m\]"

C_LIGHTBLACK="\[\033[1;30m\]"
C_LIGHTRED="\[\033[1;31m\]"
C_LIGHTGREEN="\[\033[1;32m\]"
C_LIGHTYELLOW="\[\033[1;33m\]"
C_LIGHTBLUE="\[\033[1;34m\]"
C_LIGHTMAGENTA="\[\033[1;35m\]"
C_LIGHTCYAN="\[\033[1;36m\]"
C_LIGHTWHITE="\[\033[1;37m\]"

C_BG_BLACK="\[\033[40m\]"
C_BG_RED="\[\033[41m\]"
C_BG_GREEN="\[\033[42m\]"
C_BG_YELLOW="\[\033[43m\]"
C_BG_BLUE="\[\033[44m\]"
C_BG_MAGENTA="\[\033[45m\]"
C_BG_CYAN="\[\033[46m\]"
C_BG_WHITE="\[\033[47m\]"

##############
# functions
##############


# wrapper for making a directory and changing to it in one go
function md () {
    mkdir -p "$@" && cd "$@"
}

# change dir and then list contents
function cl () {
    cd "$@" && ls
}

function cll () {
    cd "$@" && ll
}

function g {
    git ${@:-status -s}
}

function pud () {
    pushd ${@:-'.'}
}

alias pod='popd'

function o {
  open ${@:-'.'}
}

# thanks for these functions to @paulirish
# find shorthand
function f() {
    find . -name "$1"
}
# end thanks to @paulirish

# go up a directory level.
# Takes a parameter that determines the level to go up, i.e.: up 3 will
# be the same as cd ../../../

function up () {
    levels="$@"

    if [ -z "$levels" ]; then
        levels=1
    fi

    # Test if $levels is a number; the -eq operator expects a number, and will
    # output an error if one is not found. Any output to STDERR is redirected
    # to the bit bucket (/dev/null) so as not to cause unnessecary output to the
    # screen; all we
    if [ "$levels" -eq "$levels" ] 2> /dev/null; then
        if [ "$levels" -eq "0" ]; then
            levels=1
        fi

        directories=""

        for (( c=1; c<=levels; c++ ))
        do
            parent=../
            directories=${directories}${parent}
        done

        cd $directories

    #    echo Exit status: $?
    else
        echo up: expected a number, not $levels
    fi
}

# Create a data URL from a file
function dataurl() {
    if [ -z "$@" ]; then
        echo "usage: dataurl FILE" >&2
    else
        local mimeType=$(file -b --mime-type "$1")

        if [[ $mimeType == text/* ]]; then
            mimeType="${mimeType};charset=utf-8"
        fi

        echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
    fi
}

##############
# Prompt: uname in cwd on (git-branch) $
##############

function _c() {
    colour=$1
    text=$2

    echo -ne ${colour}${text}${C_DEFAULT}
}

# Fastest possible way to check if repo is dirty. a savior for the WebKit repo.
function parse_git_dirty() {
    git diff --quiet --ignore-submodules HEAD 2>/dev/null; [ $? -eq 1 ] && echo '*'
}

function parse_git_branch() {
    git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$(parse_git_dirty)/"
}

function prompt () {
    local arg=$1
    local _ps1="$(_c $C_LIGHTBLUE '\u') at $(_c $C_CYAN '\h') in $(_c $C_LIGHTBLUE '\w')\$([[ -n \$(git branch 2> /dev/null) ]] && echo \" on \")$(_c $(tput setaf 215) $(parse_git_branch)) $(_c $C_GREEN '\$') "

    case "$arg" in
        --minimal|-m)
            # echo prompt: minimal prompt
            _ps1="$(_c $C_GREEN '\$') "
            ;;
        --basic|-b)
            # echo prompt: basic prompt
            _ps1="$(_c $C_LIGHTBLUE '\u') at $(_c $C_CYAN '\h') $(_c $C_GREEN '\$') "
            ;;
        --full|-f)
            # echo prompt: full prompt
            ;;
        *)
            ;;
    esac

    export PS1=$_ps1

}

# export PS1="\[\033[G\]$C_LIGHTBLUE\u$C_DEFAULT at $C_CYAN\h$C_DEFAULT in $C_LIGHTBLUE\w\$([[ -n \$(git branch 2> /dev/null) ]] && echo \"$C_DEFAULT on \")$C_YELLOW"'$(parse_git_branch)'" $C_LIGHTGREEN\$$C_DEFAULT "
prompt

##############
# Command History settings
##############

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=100000
HISTFILESIZE=2000

export HISTIGNORE="clear:bg:fg:jobs:cd -:cd ../:ll:ls:l"

bind '"\e[A":history-search-backward'
bind '"\e[B":history-search-forward'

############## Source local bash settings
#############

if [ -f ~/.bashrc_local ]; then
    source ~/.bashrc_local
fi

